<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="Brian Barnett [ sfxBrian / brian3kb ]" />
  <meta name="version" content="v 1.0.2" />
  <meta
          name="description"
          content="DigiChain loads syx samples for/from the Machinedrum and converts them to wav files for transfer via the Transfer app. The converted files can also be joined together without, or with padding to work better with the 1.5 firmware Digitakt slice grids. Files are generated at 48Khz/16bit. When the slice-grid is on, the last sample in the chain will be repeated to pad to the selected grid size."
  />
  <title>DigiChain</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      background-color: #202124;
    }
    * { user-select: none; }
    .container { min-height: 95vh; transition: opacity .15s; }
    #getJoined, .wav-link-hidden { visibility: hidden; }
    #getJoined, #uploadInput { display: none; }
    #fileNum { padding-left: 1rem; }
    th a { margin-left: -15px; }
    canvas.waveform {
      cursor: pointer;
      opacity: .7;
      transition: opacity .2s;
      margin-top: 0.4rem;
      margin-bottom: -0.5rem;
    }
    canvas.waveform:hover { opacity: .98; }
    td { padding: 0; }
    td button { margin: 0.5rem; }
    .min-width-20 { min-width: 20rem;}
    .align-right { text-align: right; }
    .check {
      padding: 0;
      width: 4rem;
    }
    .toggle-check, .sort-check {
      outline: 0.1rem solid #d79c4e;
      border: 0.2rem solid #202124;
      width: 3.25rem;
      height: 3.25rem;
    }
    .sort-check {
      margin-left: 0.5rem;
    }
    .move-up, .move-down, .duplicate, .remove { padding: 0; }
    .gg-info {
      margin: 0.25rem;
      transform: scale(.6);
      margin-top: -0.15rem;
    }
    .channel-options {
      border: 1px solid #40392e;
      border-radius: 5px;
      margin-right: 1.5rem;
      padding: 0.5rem;
      width: 6rem;
      text-align: center;
    }
    .channel-options a {
      color: #40392e;
    }
    .channel-options a.selected {
      color: #d79c4e;
    }
    .logo {
      position: absolute;
      bottom: -4rem;
      right: 1rem;
      opacity: 0.35;
    }
    .logo h3::after {
      content: 'v 1.0.2';
      font-size: 1rem;
      position: absolute;
      margin-left: -0.75rem;
      margin-top: 2.55rem;
    }
    .info-panel-md {
      position: fixed;
      width: 50vw;
      top: 16vh;
      left: 25vw;
      z-index: 1000;
      background-color: #202124;
      border: 1px solid orange;
      padding: 2rem;
      border-radius: 5px;
      box-shadow: 0 0px 4px #cf8600;
      display: none;
    }
    a {
      cursor: pointer;
    }
    .w-0 { width: 0; }
    tr:has(.check.button-outline) {
      opacity: 0.55;
    }
    .download-buttons {
      width: 29rem;
    }
    .btn-download {
      padding: 0;
      width: 14.25rem;
    }
    .dl-spaced{
      width: 22rem;
      padding: 0;
    }
    .slice-group {
      border: 1px solid orange;
      padding: 1rem;
      border-radius: 5px;
      text-align: center;
      padding-bottom: 0.25rem;
      width: 29rem;
    }
    .button-clear.remove {
      color: #343433;
      transition: color .2s;
    }
    .button-clear.remove:hover {
      color: #5e1a1a;
    }
    .file-num {
      position: fixed;
      top: 0;
      margin-left: 1rem;
    }
    .right-buttons i {
      display: inline-block;
      margin-top: 0;
      margin-right: 0.5rem;
      top: 0.35rem;
    }
    .no-files {
      text-align: center;
      padding-top: 7rem;
      padding-bottom: 5rem;
      opacity: .25;
    }
    .loading-message {
      display: none;
      top: 40vh;
      position: fixed;
      width: 100%;
      font-size: 3rem;
      text-align: center;
    }
    .loading-message div {
      width: 32rem;
      margin: auto;
    }
    .loading-message .gg-spinner {
      transform: scale(2);
      margin-top: 4rem;
    }
    .loading-message span {
      margin-left: 5rem;
      margin-top: -3.25rem;
      display: block;
    }
    .loading .loading-message {
      display: block;
    }
    .loading .container {
      opacity: .15;
    }
    .gradient-text {
      background-color: #606c76;
      background-image: linear-gradient(90deg, #606c76, #606c76);
      background-size: 100%;
      background-repeat: repeat;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      -moz-background-clip: text;
      -moz-text-fill-color: transparent;
    }
    @media (max-width: 40.0rem) {
      .container { margin-top: 2.5rem; }
      .min-width-20, .column-33, .column-33 .download-buttons, .column-33 .slice-group { width: 100%; }
      .column-33 .btn-download { width: 49.3%;}
      .column-33 .check { width: 15.4%; }
      .column-33 .dl-spaced { width: 81.5%;}
    }
  </style>
</head>

<body>
<div class="loading-message">
  <div><i class="gg-spinner"></i><span id="loadingText" class="gradient-text">Loading samples</span></div>
</div>
<div class="container">
  <div class="row">
    <div class="column">

      <div class="row">
        <label class="button min-width-20" for="uploadInput">Load Files...</label>
        <input id="uploadInput" type="file" multiple/></div>
      <div class="row">
        <button class="min-width-20" onclick="removeSelected()">Remove Selected</button>
      </div>
      <div class="row">
        <button title="Reset list to the order in which files were added to the pool." class="min-width-20 button-outline" onclick="sort('id')">Reset Sort/Order</button>
      </div>
    </div>
    <div class="column">
      <div class="row">
        <div class="column file-num">
          <label for="fileNum" class="float-left" style="padding-left: 1rem;">Loaded/Selected</label>
          <output class="float-left" id="fileNum">0/0</output>
        </div>
      </div>
    </div>
    <div class="column-33 align-right right-buttons">
      <div class="download-buttons">
        <button class="btn-download" onclick="downloadAll()"><i class="gg-software-download"></i><span class="selection-count"> - </span></button>
        <button class="btn-download" onclick="joinAll()"><i class="gg-software-download"></i><span class="join-count"> - </span> Joined</button>
      </div>
      <div class="slice-group">
        <button title="Select 4 samples" onclick="selectSliceAmount(event, 4)" class="button-outline check sel-4">4</button>
        <button title="Select 8 samples" onclick="selectSliceAmount(event, 8)" class="button-outline check sel-8">8</button>
        <button title="Select 16 samples" onclick="selectSliceAmount(event, 16)" class="button-outline check sel-16">16</button>
        <button title="Select 32 samples" onclick="selectSliceAmount(event, 32)" class="button-outline check sel-32">32</button>
        <button title="Select 64 samples" onclick="selectSliceAmount(event, 64)" class="button-outline check sel-64">64</button>
        <button title="Select 128 samples (good for wavetables / Model:Samples 0-127 start value.)" onclick="selectSliceAmount(event, 128)" class="button-outline check sel-128">128</button><br>
        <button title="Turn off slice grid" onclick="selectSliceAmount(event, 0)" class="button check sel-0">Off</button>
        <button class="min-width-20 dl-spaced" onclick="joinAll(true)"><i class="gg-software-download"></i><span class="join-count"> - </span> Joined (Spaced)</button>
        <a id="getJoined">_</a>
      </div>
    </div>
  </div>
  <div class="row">
    <div class="column">
      <table>
        <thead>
        <tr>
          <th class="w-0"><button title="Click to sort." onclick="sort('checked')" class="button-outline check sort-check">&nbsp;</button></th>
          <th class="w-0"></th>
          <th></th>
          <th style="width: 180px;"></th>
          <th><a title="Click to sort." onclick="sort('name')">Filename / Download</a></th>
          <th><a title="Click to sort." onclick="sort('length')">Length (s)</a></th>
          <th class="w-0"></th>
          <th class="w-0"></th>
          <th class="w-0"></th>
        </tr>
        </thead>
        <tbody id="fileList">
        <tr><td class="no-files" colspan="9"><h4>Load some samples to get started...</h4></td></tr>
        </tbody>
      </table>
    </div>
  </div>
  <div class="row info-panel">
    <div class="column column-35 column-offset-75 logo">
      <h3 class="float-right">DigiChain <i class="gg-info float-right" style="cursor: pointer;" onclick="showInfo()"></i> </h3>
    </div>
  </div>
</div>

<div id="infoPanelMd" class="info-panel-md">
  <a class="float-right" onclick="document.getElementById('infoPanelMd').style.display = 'none'"><i class="gg-close"></i></a>
  <div class="content"></div>
</div>
<script>
  "use strict";
  //JavaScript Audio Resampler
  //Copyright (C) 2011-2015 Grant Galitz
  //Released to Public Domain https://raw.githubusercontent.com/taisel/XAudioJS/master/resampler.js
  function Resampler(fromSampleRate, toSampleRate, channels, inputBuffer) {
    //Input Sample Rate:
    this.fromSampleRate = +fromSampleRate;
    //Output Sample Rate:
    this.toSampleRate = +toSampleRate;
    //Number of channels:
    this.channels = channels | 0;
    //Type checking the input buffer:
    if (typeof inputBuffer != "object") {
      throw(new Error("inputBuffer is not an object."));
    }
    if (!(inputBuffer instanceof Array) && !(inputBuffer instanceof Float32Array) && !(inputBuffer instanceof Float64Array)) {
      throw(new Error("inputBuffer is not an array or a float32 or a float64 array."));
    }
    this.inputBuffer = inputBuffer;
    //Initialize the resampler:
    this.initialize();
  }
  Resampler.prototype.initialize = function () {
    //Perform some checks:
    if (this.fromSampleRate > 0 && this.toSampleRate > 0 && this.channels > 0) {
      if (this.fromSampleRate == this.toSampleRate) {
        //Setup a resampler bypass:
        this.resampler = this.bypassResampler;		//Resampler just returns what was passed through.
        this.ratioWeight = 1;
        this.outputBuffer = this.inputBuffer;
      }
      else {
        this.ratioWeight = this.fromSampleRate / this.toSampleRate;
        if (this.fromSampleRate < this.toSampleRate) {
          /*
            Use generic linear interpolation if upsampling,
            as linear interpolation produces a gradient that we want
            and works fine with two input sample points per output in this case.
          */
          this.compileLinearInterpolationFunction();
          this.lastWeight = 1;
        }
        else {
          /*
            Custom resampler I wrote that doesn't skip samples
            like standard linear interpolation in high downsampling.
            This is more accurate than linear interpolation on downsampling.
          */
          this.compileMultiTapFunction();
          this.tailExists = false;
          this.lastWeight = 0;
        }
        this.initializeBuffers();
      }
    }
    else {
      throw(new Error("Invalid settings specified for the resampler."));
    }
  }
  Resampler.prototype.compileLinearInterpolationFunction = function () {
    var toCompile = "var outputOffset = 0;\
    if (bufferLength > 0) {\
        var buffer = this.inputBuffer;\
        var weight = this.lastWeight;\
        var firstWeight = 0;\
        var secondWeight = 0;\
        var sourceOffset = 0;\
        var outputOffset = 0;\
        var outputBuffer = this.outputBuffer;\
        for (; weight < 1; weight += " + this.ratioWeight + ") {\
            secondWeight = weight % 1;\
            firstWeight = 1 - secondWeight;";
    for (var channel = 0; channel < this.channels; ++channel) {
      toCompile += "outputBuffer[outputOffset++] = (this.lastOutput[" + channel + "] * firstWeight) + (buffer[" + channel + "] * secondWeight);";
    }
    toCompile += "}\
        weight -= 1;\
        for (bufferLength -= " + this.channels + ", sourceOffset = Math.floor(weight) * " + this.channels + "; sourceOffset < bufferLength;) {\
            secondWeight = weight % 1;\
            firstWeight = 1 - secondWeight;";
    for (var channel = 0; channel < this.channels; ++channel) {
      toCompile += "outputBuffer[outputOffset++] = (buffer[sourceOffset" + ((channel > 0) ? (" + " + channel) : "") + "] * firstWeight) + (buffer[sourceOffset + " + (this.channels + channel) + "] * secondWeight);";
    }
    toCompile += "weight += " + this.ratioWeight + ";\
            sourceOffset = Math.floor(weight) * " + this.channels + ";\
        }";
    for (var channel = 0; channel < this.channels; ++channel) {
      toCompile += "this.lastOutput[" + channel + "] = buffer[sourceOffset++];";
    }
    toCompile += "this.lastWeight = weight % 1;\
    }\
    return outputOffset;";
    this.resampler = Function("bufferLength", toCompile);
  }
  Resampler.prototype.compileMultiTapFunction = function () {
    var toCompile = "var outputOffset = 0;\
    if (bufferLength > 0) {\
        var buffer = this.inputBuffer;\
        var weight = 0;";
    for (var channel = 0; channel < this.channels; ++channel) {
      toCompile += "var output" + channel + " = 0;"
    }
    toCompile += "var actualPosition = 0;\
        var amountToNext = 0;\
        var alreadyProcessedTail = !this.tailExists;\
        this.tailExists = false;\
        var outputBuffer = this.outputBuffer;\
        var currentPosition = 0;\
        do {\
            if (alreadyProcessedTail) {\
                weight = " + this.ratioWeight + ";";
    for (channel = 0; channel < this.channels; ++channel) {
      toCompile += "output" + channel + " = 0;"
    }
    toCompile += "}\
            else {\
                weight = this.lastWeight;";
    for (channel = 0; channel < this.channels; ++channel) {
      toCompile += "output" + channel + " = this.lastOutput[" + channel + "];"
    }
    toCompile += "alreadyProcessedTail = true;\
            }\
            while (weight > 0 && actualPosition < bufferLength) {\
                amountToNext = 1 + actualPosition - currentPosition;\
                if (weight >= amountToNext) {";
    for (channel = 0; channel < this.channels; ++channel) {
      toCompile += "output" + channel + " += buffer[actualPosition++] * amountToNext;"
    }
    toCompile += "currentPosition = actualPosition;\
                    weight -= amountToNext;\
                }\
                else {";
    for (channel = 0; channel < this.channels; ++channel) {
      toCompile += "output" + channel + " += buffer[actualPosition" + ((channel > 0) ? (" + " + channel) : "") + "] * weight;"
    }
    toCompile += "currentPosition += weight;\
                    weight = 0;\
                    break;\
                }\
            }\
            if (weight <= 0) {";
    for (channel = 0; channel < this.channels; ++channel) {
      toCompile += "outputBuffer[outputOffset++] = output" + channel + " / " + this.ratioWeight + ";"
    }
    toCompile += "}\
            else {\
                this.lastWeight = weight;";
    for (channel = 0; channel < this.channels; ++channel) {
      toCompile += "this.lastOutput[" + channel + "] = output" + channel + ";"
    }
    toCompile += "this.tailExists = true;\
                break;\
            }\
        } while (actualPosition < bufferLength);\
    }\
    return outputOffset;";
    this.resampler = Function("bufferLength", toCompile);
  }
  Resampler.prototype.bypassResampler = function (upTo) {
    return upTo;
  }
  Resampler.prototype.initializeBuffers = function () {
    //Initialize the internal buffer:
    var outputBufferSize = (Math.ceil(this.inputBuffer.length * this.toSampleRate / this.fromSampleRate / this.channels * 1.000000476837158203125) * this.channels) + this.channels;
    try {
      this.outputBuffer = new Float32Array(outputBufferSize);
      this.lastOutput = new Float32Array(this.channels);
    }
    catch (error) {
      this.outputBuffer = [];
      this.lastOutput = [];
    }
  }
</script>
<script>
  /*
  TODO:
   - Add start/end point selection to table for sample export.
   - Shift-double-click the slice-grid buttons to select randomly.
   - MIDI input to preview with a device connected. (channel picker)
   - Change default name (other than joined.wav)
   - Buffer shuffler, randomize the buffer assignment to glitch exported samples.
  * */

  const uploadInput = document.getElementById('uploadInput');
  const masterSR = 48000;
  const audioCtx = new AudioContext({sampleRate: masterSR});
  let files = [];
  let unsorted = [];
  let lastSort = '';
  let sliceGrid = 0;

  const getFileById = (id) => {
    return files.find(f => f.meta.id === id);
  };
  const getFileIndexById = (id) => {
    return files.findIndex(f => f.meta.id === id);
  };
  const getRowElementById = (id) => {
    return document.querySelector(`tr[data-id="${id}"]`);
  };
  function setWavLink(file, linkEl) {

    const wav = audioBufferToWav(file.buffer, file.meta);
    const blob = new window.Blob([new DataView(wav)], {
      type: 'audio/wav',
    });

    linkEl.href = URL.createObjectURL(blob);
    linkEl.setAttribute('download', file.file.name.replace('.syx', '.wav'));
  }

  function downloadAll() {
    const _files = files.filter(f => f.meta.checked);
    if (_files.length > 5) {
      const userReadyForTheCommitment = confirm(`You are about to download ${_files.length} files, that will show ${_files.length} pop-ups one after each other..\n\nAre you ready for that??`);
      if (!userReadyForTheCommitment) { return; }
    }
    _files.forEach(file => {
        setTimeout(
          () => downloadFile(file.meta.id), 100
        )
    });
  }

  function downloadFile(id) {
    const el = getRowElementById(id).querySelector('.wav-link-hidden');
    const file = getFileById(id);
    setWavLink(file, el);
    el.click();
  }

  function removeSelected() {
    files.forEach(f => f.meta.checked ? f.source?.stop() : '' );
    files = files.filter(f => !f.meta.checked);
    unsorted = unsorted.filter(id => files.find(f => f.meta.id === id));
    renderList();
  }

  function showInfo() {
    const name = document.querySelector('meta[name=author]').content;
    const description = document.querySelector('meta[name=description]').content;
    const infoPanelContent = document.querySelector('.info-panel-md .content');
    infoPanelContent.innerHTML = `<h3>DigiChain</h3><p>${description}</p><p class="float-right">${name}</p>`;
    document.querySelector('.info-panel-md').style.display = 'block';
  }

  function joinAll(pad = false, filesRemaining = [], fileCount = 0) {
    if (files.length === 0) { return; }
    let _files = filesRemaining.length > 0 ? filesRemaining : files.filter(f => f.meta.checked);
    let tempFiles = _files.splice(0, (sliceGrid > 0 ? sliceGrid : _files.length));
    filesRemaining = Array.from(_files);
    _files = tempFiles;
    if (pad && sliceGrid !== 0 && _files.length !== 0) {
      while (_files.length !== sliceGrid) {
        _files.push(_files[_files.length - 1]);
      }
    }
    const largest = _files.reduce((big, cur) => big > cur.buffer.length ? big : cur.buffer.length, 0);
    const totalLength = _files.reduce((total, file) => {
      total +=  pad ? largest : file.buffer.length;
      return total;
    }, 0);
    const audioArrayBuffer = audioCtx.createBuffer(
            1,
            totalLength,
            masterSR
    );
    let totalWrite = 0;
    _files.forEach((file, idx) => {
      const bufferLength = pad ? largest : file.buffer.length;
      let result = new Float32Array(file.buffer.length);

      if (file.meta.channel) {
        if (file.meta.channel === 'L') { result = file.buffer.getChannelData(0); }
        if (file.meta.channel === 'R') { result = file.buffer.getChannelData(1); }
        if (file.meta.channel === 'S') {
          for (let i = 0; i < file.buffer.length; i++) {
            result[i] = (file.buffer.getChannelData(0)[i] + file.buffer.getChannelData(1)[i]) / 2;
          }
        }
      } else {
        result = file.buffer.getChannelData(0);
      }

      for (let i = 0; i < bufferLength; i++) {
        audioArrayBuffer.getChannelData(0)[totalWrite] = result[i];
        totalWrite++;
      }
    });
    const joinedEl = document.getElementById('getJoined');
    setWavLink({file: {name: `joined_${fileCount}.wav`}, buffer: audioArrayBuffer, meta: {}}, joinedEl);
    joinedEl.click();
    if (filesRemaining.length > 0) {
      fileCount++
      joinAll(pad, filesRemaining, fileCount);
    }
  }

  const playFile = (event, id, loop) => {
    const file = getFileById(id);
    loop = loop || event.shiftKey || false;
    if (file.source) {
      file.source.stop();
    }
    file.source = audioCtx.createBufferSource();
    file.source.buffer = file.buffer;
    file.source.connect(audioCtx.destination);
    file.source.loop = loop;
    file.source.start();
  };

  const toggleCheck = (id) => {
    const el = getRowElementById(id).querySelector('.toggle-check');
    const file = getFileById(id);
    file.meta.checked = !file.meta.checked;
    file.meta.checked ? el.classList.remove('button-outline') : el.classList.add('button-outline');
    if (!file.meta.checked) {
      file.source?.stop();
    }
    setCountValues();
  };

  const changeChannel = (id, channel) => {
    const el = getRowElementById(id).querySelector('.channel-option-' + channel);
    const file = getFileById(id);
    file.meta.channel = channel;
   getRowElementById(id).querySelectorAll('.channel-options a').forEach(opt => opt.classList.remove('selected'));
    el.classList.add('selected');
  };

  const selectSliceAmount = (event, size) => {
    const options = [0, 4, 8, 16, 32, 64, 128];
    sliceGrid = size;
    options.forEach(option => {
      const el = document.querySelector(`.sel-${option}`);
      option === size ?
              el.classList.remove('button-outline') :
              el.classList.add('button-outline');
    });
    setCountValues();
    if (size === 0) {
      files.forEach(f => f.source?.stop());
    }
    if (event.shiftKey) { return; } /*Shift-click to change grid but keep selections.*/
    files.forEach(f => f.meta.checked = false);
    for (let i = 0; i < (size < files.length ? size : files.length) ; i++) {
      toggleCheck(files[i].meta.id);
    }
    renderList();
  }

  const duplicate = (event, id) => {
    const file = getFileById(id);
    const fileIdx = getFileIndexById(id);
    const item = Object.assign({}, file);
    item.meta = Object.assign({}, file.meta);
    item.meta.dupeOf = id;
    item.waveform = false;
    item.meta.id = crypto.randomUUID();
    files.splice((event.shiftKey ? files.length : fileIdx + 1), 0, item);
    unsorted.push(item.meta.id);
    renderList();
  };

  const remove = (id) => {
    const fileIdx = getFileIndexById(id);
    files.splice(fileIdx, 1);
    const unsortIdx = unsorted.findIndex(uuid => uuid === id);
    unsorted.splice(unsortIdx, 1);
    renderList();
  }

  const move = (event, id, direction) => {
    const from = getFileIndexById(id);
    let item;
    let to = direction === 1 ? (from + 1) : (from - 1);
    if (to === -1) { to = files.length - 1; }
    if (to >= files.length) { to = 0; }
    item = files.splice(from, 1)[0];
    if (event.shiftKey) { /*If shift key, move to top or bottom of list.*/
      from > to ? files.splice(0, 0, item): files.splice(files.length, 0, item);
    } else {
      files.splice(to, 0, item);
    }
    renderList();
  };
  const sort = (by) => {
    if (by === 'id') {
      files = unsorted.map(key => files.find(f => f.meta.id === key));
      lastSort = '';
    } else {
      if (lastSort === by) {
        files.reverse();
      } else {
        files = by === 'name' ?
                files.sort((a, b) => a.file[by].localeCompare(b.file[by])) :
                files.sort((a, b) => a.meta[by] - b.meta[by]);
        lastSort = by;
      }
    }
    renderList();
  };

  const draw = (normalizedData, id) => {
    const drawLineSegment = (ctx, x, height, width, isEven) => {
      ctx.lineWidth = 1; // how thick the line is
      ctx.strokeStyle = '#a8a8a8'; // what color our line is
      ctx.beginPath();
      height = isEven ? height : -height;
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.arc(x + width / 2, height, width / 2, Math.PI, 0, isEven);
      ctx.lineTo(x + width, 0);
      ctx.stroke();
    };
    // set up the canvas
    const canvas = document.querySelector('canvas.waveform-'+id);
    const dpr = window.devicePixelRatio || 1;
    const padding = 0;
    canvas.width = 150; //canvas.offsetWidth * dpr;
    canvas.height = 60;// (canvas.offsetHeight + padding * 2) * dpr;
    const ctx = canvas.getContext('2d');
    //ctx.scale(dpr, dpr);
    ctx.translate(0, canvas.offsetHeight / 2 + padding); // set Y = 0 to be in the middle of the canvas

    // draw the line segments
    const width = canvas.offsetWidth / normalizedData.length;
    for (let i = 0; i < normalizedData.length; i++) {
      const x = width * i;
      let height = (normalizedData[i] / 3) * canvas.offsetHeight - padding;
      if (height < 0) {
        height = 0;
      } else if (height > canvas.offsetHeight / 2) {
        height = height > canvas.offsetHeight / 2;
      }
      drawLineSegment(ctx, x, height, width, (i + 1) % 2);
    }
  };

  const setCountValues = () => {
    const selectionCount = files.filter(f => f.meta.checked).length;
    document.getElementById('fileNum').textContent = `${files.length}/${selectionCount}`;
    document.querySelector('.selection-count').textContent = ` ${selectionCount || '-'} `;
    document.querySelectorAll('.join-count').forEach(el => el.textContent = ` ${selectionCount === 0 ? '-' : (selectionCount > 0 && sliceGrid > 0 ? Math.ceil(selectionCount / sliceGrid) : '1')} `);
  };

  const renderList = () => {
    const listEl = document.getElementById('fileList');
    listEl.innerHTML = files.map( f => `
      <tr data-id="${f.meta.id}">
        <td>
            <button onclick="toggleCheck('${f.meta.id}')" class="${f.meta.checked ? '' : 'button-outline'} check toggle-check">&nbsp;</button>
        </td>
        <td>
            <button title="Move up in sample list." onclick="move(event, '${f.meta.id}', -1)" class="button-clear move-up"><i class="gg-chevron-up-r"></i></button>
        </td>
        <td>
            <button title="Move down in sample list." onclick="move(event, '${f.meta.id}', 1)" class="button-clear move-down"><i class="gg-chevron-down-r"></i></button>
        </td>
        <td>
            <canvas onclick="playFile(event, '${f.meta.id}')" class="waveform waveform-${f.meta.id}"></canvas>
        </td>
        <td>
            <a title="Download processed wav file of sample." class="wav-link" onclick="downloadFile('${f.meta.id}')">${f.file.name.replace(
            /\.syx$|\.wav$/, '')}</a>${f.meta.dupeOf ? ' d' : ''}<a class="wav-link-hidden"></a>
        </td>
        <td>
            <span>${f.meta.duration} s</span>
        </td>
        <td>
            <div class="channel-options" style="display: ${f.buffer.numberOfChannels > 1 ? 'block' : 'none'}">
            <a title="Left channel" onclick="changeChannel('${f.meta.id}', 'L')" class="${f.meta.channel === 'L' ? 'selected' : ''} channel-option-L">L</a>
            <a title="Sum to mono" onclick="changeChannel('${f.meta.id}', 'S')" class="${f.meta.channel === 'S' ? 'selected' : ''} channel-option-S">S</a>
            <a title="Right channel" onclick="changeChannel('${f.meta.id}', 'R')" class="${f.meta.channel === 'R' ? 'selected' : ''} channel-option-R">R</a>
            </div>
        </td>
        <td>
            <button title="Duplicate sample." onclick="duplicate(event, '${f.meta.id}')" class="button-clear duplicate"><i class="gg-duplicate"></i></button>
        </td>
        <td>
            <button title="Remove sample (double-click)." ondblclick="remove('${f.meta.id}')" class="button-clear remove"><i class="gg-trash"></i></button>
        </td>
      </tr>
    `).join('');
    if (files.length === 0) {
      listEl.innerHTML = `<tr><td colspan="9" class="no-files"><h4>Load some samples to get started...</h4></td></tr>`;
    }

    document.querySelectorAll('.waveform').forEach((el, i) => {
      if (files[i].waveform) {
        el.replaceWith(files[i].waveform);
      } else {
        draw([...files[i].buffer.getChannelData(0)].filter((x, i) => !(i /50 % 1)), files[i].meta.id);
        files[i].waveform = el;
      }
    });
    setCountValues();
    document.body.classList.remove('loading');
  };
  const bytesToInt = (bh, bm, bl) => {
    return ((bh & 0x7f) << 7 << 7) + ((bm & 0x7f) << 7) + (bl & 0x7f);
  };
  const parseSds = (fd, file) => {
    // Check header is correct.
    if (!(fd[0] === 240 && fd[1] === 126 && fd[3] === 1 && fd[20] === 247)) {
      return false;
    }
    const uuid = crypto.randomUUID();
    const bitRate = fd[6];
    const sampleRate = Math.ceil(10e7 / bytesToInt(fd[9], fd[8], fd[7])) * 10;
    const length = bytesToInt(fd[12], fd[11], fd[10]);
    let loopStart = bytesToInt(fd[15], fd[14], fd[13]);
    let loopEnd = bytesToInt(fd[18], fd[17], fd[16]) + 1;
    const loopType = fd[19];

    if (loopType === 0x7f) { loopStart = loopEnd = length; }
    if (sampleRate < 4000 || sampleRate > 96000) { return false; }
    if (bitRate !== 16) { return false; }

    const startIndex = fd.findIndex(
            (x, i) => (x === 0xf0 && fd[i + 1] === 0x7e && fd[i + 3] === 0x02 && fd[i + 126] === 0xf7));

    let idx = startIndex;
    let lengthRead = 0;
    let data = [];

    while (lengthRead < length) {
      for (let t = (idx + 5); t < (idx + 125) && lengthRead < length; t += 3) {
        let val = (((fd[t] << 9) | (fd[t + 1] << 2) | (fd[t + 2] >> 5)) - 0x8000);
        data[lengthRead++] = val;
      }
      idx = idx + 127;
    }

    const resample = new Resampler(sampleRate, masterSR, 1, data.filter(x => x !== undefined));
    resample.resampler(resample.inputBuffer.length);
    const audioArrayBuffer = audioCtx.createBuffer(
            1,
            resample.outputBuffer.length - ((resample.outputBuffer.length / 120) * 5),
            masterSR
    );
    resample.outputBuffer.filter(x => x !== undefined).forEach((y, i) => audioArrayBuffer.getChannelData(0)[i] = y / 32767);

    files.push({
      file: file, buffer: audioArrayBuffer, meta: {
        bitRate, masterSR, length: resample.outputBuffer.length, loopStart, loopEnd, loopType,
        duration: Number(resample.outputBuffer.length / masterSR).toFixed(4),
        startFrame: 0, endFrame: resample.outputBuffer.length,
        checked: true, id: uuid
      }
    });
    unsorted.push(uuid);
    return uuid;
  };

  const parseWav = (audioArrayBuffer, file) => {
    const uuid = crypto.randomUUID();
    /*duration, length, numberOfChannels, sampleRate*/
    files.push({
      file: file, buffer: audioArrayBuffer, meta: {
        masterSR, length: audioArrayBuffer.length,
        duration: Number(audioArrayBuffer.length / masterSR).toFixed(4),
        startFrame: 0, endFrame: audioArrayBuffer.length,
        checked: true, id: uuid,
        channel: 'L'
      }
    });
    unsorted.push(uuid);
    return uuid;
  };

  const renderListWhenReady = (count) => {
    count = count.filter(c => c !== false);
    if (count.every(c => unsorted.includes(c))) {
      renderList();
    } else {
      setTimeout(() => renderListWhenReady(count), 1000);
    }
  }

  const setLoadingProgress = (count, total) => {
    const el = document.getElementById('loadingText');
    let progress = (count/total) * 100;
    el.style.backgroundImage = `linear-gradient(90deg, #cf8600 ${progress}%, #606c76 ${progress + 1}%, #606c76 100%)`;
  };

  uploadInput.addEventListener(
          'change',
           () => {
            // Calculate total size
            let numberOfBytes = 0;
            let count = [];
             document.body.classList.add('loading');
            [...uploadInput.files].forEach((file, idx) => {
              numberOfBytes += file.size;
              var reader = new FileReader();
              reader.onload = async function(e) {
                if (file.name.toLowerCase().endsWith('.syx')) {
                  // binary data
                  const buffer = e.target.result;
                  const bufferByteLength = buffer.byteLength;
                  const bufferUint8Array = new Uint8Array(buffer, 0, bufferByteLength);
                  count.push(parseSds(bufferUint8Array, file));
                }

                if (file.name.toLowerCase().endsWith('.wav')) {
                  await audioCtx.decodeAudioData(e.target.result, data => count.push(parseWav(data, file)));
                }
                //document.getElementById('samplesLoadedProgress').textContent = ` (${idx + 1} / ${files.length})`;
                setLoadingProgress(idx + 1, files.length);
              };
              reader.readAsArrayBuffer(file);
            });
            setTimeout(() => renderListWhenReady(count), 500);
          },
          false,
  );

  /*---*/

  function audioBufferToWav(buffer, meta) {
    const sampleRate = masterSR;
    const format = meta.float32 ? 3 : 1;
    const bitDepth = (meta.format || meta.bitRate) === 3 ? 32 : 16;
    let numChannels = buffer.numberOfChannels;

    let result;
    if (meta.channel) {
      numChannels = 1;
      if (meta.channel === 'L') { result = buffer.getChannelData(0); }
      if (meta.channel === 'R') { result = buffer.getChannelData(1); }
      if (meta.channel === 'S') {
        result = new Float32Array(buffer.length);
        for (let i = 0; i < buffer.length; i++) {
          result[i] = (buffer.getChannelData(0)[i] + buffer.getChannelData(1)[i]) / 2;
        }
      }
    } else {
      if (numChannels === 2) {
        result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));
      } else {
        result = buffer.getChannelData(0);
      }
    }
    return encodeWAV(result, format, sampleRate, numChannels, bitDepth);
  }

  function encodeWAV(samples, format, sampleRate, numChannels, bitDepth) {
    var bytesPerSample = bitDepth / 8;
    var blockAlign = numChannels * bytesPerSample;

    var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);
    var view = new DataView(buffer);

    /* RIFF identifier */
    writeString(view, 0, 'RIFF');
    /* RIFF chunk length */
    view.setUint32(4, 36 + samples.length * bytesPerSample, true);
    /* RIFF type */
    writeString(view, 8, 'WAVE');
    /* format chunk identifier */
    writeString(view, 12, 'fmt ');
    /* format chunk length */
    view.setUint32(16, 16, true);
    /* sample format (raw) */
    view.setUint16(20, format, true);
    /* channel count */
    view.setUint16(22, numChannels, true);
    /* sample rate */
    view.setUint32(24, sampleRate, true);
    /* byte rate (sample rate * block align) */
    view.setUint32(28, sampleRate * blockAlign, true);
    /* block align (channel count * bytes per sample) */
    view.setUint16(32, blockAlign, true);
    /* bits per sample */
    view.setUint16(34, bitDepth, true);
    /* data chunk identifier */
    writeString(view, 36, 'data');
    /* data chunk length */
    view.setUint32(40, samples.length * bytesPerSample, true);
    if (format === 1) { // Raw PCM
      floatTo16BitPCM(view, 44, samples);
    } else {
      writeFloat32(view, 44, samples);
    }

    return buffer;
  }

  function interleave(inputL, inputR) {
    var length = inputL.length + inputR.length;
    var result = new Float32Array(length);

    var index = 0;
    var inputIndex = 0;

    while (index < length) {
      result[index++] = inputL[inputIndex];
      result[index++] = inputR[inputIndex];
      inputIndex++;
    }
    return result;
  }

  function writeFloat32(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 4) {
      output.setFloat32(offset, input[i], true);
    }
  }

  function floatTo16BitPCM(output, offset, input) {
    for (var i = 0; i < input.length; i++, offset += 2) {
      var s = Math.max(-1, Math.min(1, input[i]));
      output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
  }

  function writeString(view, offset, string) {
    for (var i = 0; i < string.length; i++) {
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }

  /*Resources used:
		https://github.com/Jam3/audiobuffer-to-wav
		https://github.com/eh2k/uwedit/blob/master/core/MidiSDS.cpp
		https://css-tricks.com/making-an-audio-waveform-visualizer-with-vanilla-javascript/
	*/
</script>
</body>
</html>
