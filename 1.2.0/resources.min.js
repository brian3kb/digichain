export function audioBufferToWav(buffer,meta,sampleRate,bitDepth,masterNumChannels){let result,numChannels=buffer.numberOfChannels,format=meta?.float32?3:1;if(meta.channel&&1===masterNumChannels){if(numChannels=1,"L"===meta.channel&&(result=buffer.getChannelData(0)),"R"===meta.channel&&(result=buffer.getChannelData(1)),"S"===meta.channel){result=new Float32Array(buffer.length);for(let i=0;i<buffer.length;i++)result[i]=(buffer.getChannelData(0)[i]+buffer.getChannelData(1)[i])/2}}else result=2===numChannels?interleave(buffer.getChannelData(0),buffer.getChannelData(1)):buffer.getChannelData(0);return encodeWAV(result,format,sampleRate,numChannels,bitDepth)}DataView.prototype.setInt24=function(pos,val,littleEndian){this.setInt8(pos,255&val,littleEndian),this.setInt16(pos+1,val>>8,littleEndian)};export function encodeWAV(samples,format,sampleRate,numChannels,bitDepth){var bytesPerSample=bitDepth/8,blockAlign=numChannels*bytesPerSample,buffer=new ArrayBuffer(44+samples.length*bytesPerSample),view=new DataView(buffer);return writeString(view,0,"RIFF"),view.setUint32(4,36+samples.length*bytesPerSample,!0),writeString(view,8,"WAVE"),writeString(view,12,"fmt "),view.setUint32(16,16,!0),view.setUint16(20,format,!0),view.setUint16(22,numChannels,!0),view.setUint32(24,sampleRate,!0),view.setUint32(28,sampleRate*blockAlign,!0),view.setUint16(32,blockAlign,!0),view.setUint16(34,bitDepth,!0),writeString(view,36,"data"),view.setUint32(40,samples.length*bytesPerSample,!0),16===bitDepth?floatTo16BitPCM(view,44,samples):24===bitDepth?floatTo24BitPCM(view,44,samples):writeFloat32(view,44,samples),buffer}function interleave(inputL,inputR){for(var length=inputL.length+inputR.length,result=new Float32Array(length),index=0,inputIndex=0;index<length;)result[index++]=inputL[inputIndex],result[index++]=inputR[inputIndex],inputIndex++;return result}function writeFloat32(output,offset,input){for(var i=0;i<input.length;i++,offset+=4)output.setFloat32(offset,input[i],!0)}function floatTo16BitPCM(output,offset,input){for(var i=0;i<input.length;i++,offset+=2){var s=Math.max(-1,Math.min(1,input[i]));output.setInt16(offset,s<0?32768*s:32767*s,!0)}}function floatTo24BitPCM(output,offset,input){for(var i=0;i<input.length;i++,offset+=3){var s=Math.floor(8388608*input[i]+.5);output.setInt24(offset,s,!0)}}function writeString(view,offset,string){for(var i=0;i<string.length;i++)view.setUint8(offset+i,string.charCodeAt(i))}export function Resampler(fromSampleRate,toSampleRate,channels,inputBuffer){if(this.fromSampleRate=+fromSampleRate,this.toSampleRate=+toSampleRate,this.channels=0|channels,"object"!=typeof inputBuffer)throw new Error("inputBuffer is not an object.");if(!(inputBuffer instanceof Array||inputBuffer instanceof Float32Array||inputBuffer instanceof Float64Array))throw new Error("inputBuffer is not an array or a float32 or a float64 array.");this.inputBuffer=inputBuffer,this.initialize()}Resampler.prototype.initialize=function(){if(!(this.fromSampleRate>0&&this.toSampleRate>0&&this.channels>0))throw new Error("Invalid settings specified for the resampler.");this.fromSampleRate==this.toSampleRate?(this.resampler=this.bypassResampler,this.ratioWeight=1,this.outputBuffer=this.inputBuffer):(this.ratioWeight=this.fromSampleRate/this.toSampleRate,this.fromSampleRate<this.toSampleRate?(this.compileLinearInterpolationFunction(),this.lastWeight=1):(this.compileMultiTapFunction(),this.tailExists=!1,this.lastWeight=0),this.initializeBuffers())},Resampler.prototype.compileLinearInterpolationFunction=function(){for(var toCompile="var outputOffset = 0;    if (bufferLength > 0) {        var buffer = this.inputBuffer;        var weight = this.lastWeight;        var firstWeight = 0;        var secondWeight = 0;        var sourceOffset = 0;        var outputOffset = 0;        var outputBuffer = this.outputBuffer;        for (; weight < 1; weight += "+this.ratioWeight+") {            secondWeight = weight % 1;            firstWeight = 1 - secondWeight;",channel=0;channel<this.channels;++channel)toCompile+="outputBuffer[outputOffset++] = (this.lastOutput["+channel+"] * firstWeight) + (buffer["+channel+"] * secondWeight);";toCompile+="}        weight -= 1;        for (bufferLength -= "+this.channels+", sourceOffset = Math.floor(weight) * "+this.channels+"; sourceOffset < bufferLength;) {            secondWeight = weight % 1;            firstWeight = 1 - secondWeight;";for(channel=0;channel<this.channels;++channel)toCompile+="outputBuffer[outputOffset++] = (buffer[sourceOffset"+(channel>0?" + "+channel:"")+"] * firstWeight) + (buffer[sourceOffset + "+(this.channels+channel)+"] * secondWeight);";toCompile+="weight += "+this.ratioWeight+";            sourceOffset = Math.floor(weight) * "+this.channels+";        }";for(channel=0;channel<this.channels;++channel)toCompile+="this.lastOutput["+channel+"] = buffer[sourceOffset++];";toCompile+="this.lastWeight = weight % 1;    }    return outputOffset;",this.resampler=Function("bufferLength",toCompile)},Resampler.prototype.compileMultiTapFunction=function(){for(var toCompile="var outputOffset = 0;    if (bufferLength > 0) {        var buffer = this.inputBuffer;        var weight = 0;",channel=0;channel<this.channels;++channel)toCompile+="var output"+channel+" = 0;";for(toCompile+="var actualPosition = 0;        var amountToNext = 0;        var alreadyProcessedTail = !this.tailExists;        this.tailExists = false;        var outputBuffer = this.outputBuffer;        var currentPosition = 0;        do {            if (alreadyProcessedTail) {                weight = "+this.ratioWeight+";",channel=0;channel<this.channels;++channel)toCompile+="output"+channel+" = 0;";for(toCompile+="}            else {                weight = this.lastWeight;",channel=0;channel<this.channels;++channel)toCompile+="output"+channel+" = this.lastOutput["+channel+"];";for(toCompile+="alreadyProcessedTail = true;            }            while (weight > 0 && actualPosition < bufferLength) {                amountToNext = 1 + actualPosition - currentPosition;                if (weight >= amountToNext) {",channel=0;channel<this.channels;++channel)toCompile+="output"+channel+" += buffer[actualPosition++] * amountToNext;";for(toCompile+="currentPosition = actualPosition;                    weight -= amountToNext;                }                else {",channel=0;channel<this.channels;++channel)toCompile+="output"+channel+" += buffer[actualPosition"+(channel>0?" + "+channel:"")+"] * weight;";for(toCompile+="currentPosition += weight;                    weight = 0;                    break;                }            }            if (weight <= 0) {",channel=0;channel<this.channels;++channel)toCompile+="outputBuffer[outputOffset++] = output"+channel+" / "+this.ratioWeight+";";for(toCompile+="}            else {                this.lastWeight = weight;",channel=0;channel<this.channels;++channel)toCompile+="this.lastOutput["+channel+"] = output"+channel+";";toCompile+="this.tailExists = true;                break;            }        } while (actualPosition < bufferLength);    }    return outputOffset;",this.resampler=Function("bufferLength",toCompile)},Resampler.prototype.bypassResampler=function(upTo){return upTo},Resampler.prototype.initializeBuffers=function(){var outputBufferSize=Math.ceil(this.inputBuffer.length*this.toSampleRate/this.fromSampleRate/this.channels*1.0000004768371582)*this.channels+this.channels;try{this.outputBuffer=new Float32Array(outputBufferSize),this.lastOutput=new Float32Array(this.channels)}catch(error){this.outputBuffer=[],this.lastOutput=[]}},CanvasRenderingContext2D.prototype.clear=CanvasRenderingContext2D.prototype.clear||function(preserveTransform){preserveTransform&&(this.save(),this.setTransform(1,0,0,1,0,0)),this.clearRect(0,0,this.canvas.width,this.canvas.height),this.beginPath(),preserveTransform&&this.restore()};